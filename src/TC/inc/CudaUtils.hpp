/*
 * Copyright 2024 Vision Labs LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *    http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "LibCuda.hpp"
#include "TC_CORE.hpp"
#include "tc_export.h" // Generated by cmake
#include <NppCommon.hpp>

#include <mutex>
#include <utility>
#include <vector>

namespace VPF {
/* Check CUDA driver API return code, throw std::runtime_error with description
 * in case of failure;
 */
void ThrowOnCudaError(CUresult res, int lineNum);

/* Check NPP return code, throw std::runtime_error with description
 * in case of failure;
 */
void ThrowOnNppError(NppStatus res, int lineNum);

/* Get CUDA context associated with given device pointer.
 * May throw exception with reason in message;
 */
CUcontext GetContextByDptr(CUdeviceptr dptr);

/* Get CUDA context associated with given stream.
 * May throw exception with reason in message;
 */
CUcontext GetContextByStream(CUstream str);
CUcontext GetContextByStream(int gpu_id, CUstream str);

/* Get CUDA device id for given CUdeviceptr;
 * May throw exception with reason in message;
 */
int GetDeviceIdByDptr(CUdeviceptr dptr);

/* Get CUDA device pointer attribute;
 * May throw exception with reason in message;
 */
CUdeviceptr GetDevicePointer(CUdeviceptr dptr);

/* Get CUDA device id by given context;
 * May throw exception with reason in message;
 */
int GetDeviceIdByContext(CUcontext ctx);

/* Get CUDA device id by given stream;
 * May throw exception with reason in message;
 */
int GetDeviceIdByStream(CUstream str);

/* Callback to sync CUDA stream;
 */
void CudaStreamSync(void* args);

/* RAII-style CUDA Context sync;
 */
class TC_EXPORT CudaStrSync final {
  CUstream str;

public:
  explicit CudaStrSync(CUstream stream);
  ~CudaStrSync();
};

/* RAII-style CUDA Context (un)lock;
 */
class TC_EXPORT CudaCtxPush final {
public:
  explicit CudaCtxPush(CUcontext ctx);
  explicit CudaCtxPush(CUstream str);
  ~CudaCtxPush();
};

/* RAII-style CUDA event wrapper;
 */
class TC_EXPORT CudaStreamEvent final {
  CUevent m_event;
  CUcontext m_ctx;
  CUstream m_str;

public:
  CudaStreamEvent() = delete;
  CudaStreamEvent& operator=(const CudaStreamEvent&) = delete;
  CudaStreamEvent(CUstream stream, int primary_ctx_gpu_id = -1);
  ~CudaStreamEvent();

  void Record();
  void Wait();
  inline CUevent Get() noexcept { return m_event; }
};

class CudaResMgr {
private:
  CudaResMgr();

public:
  CudaResMgr(const CudaResMgr& other) = delete;
  CudaResMgr(const CudaResMgr&& other) = delete;
  CudaResMgr& operator=(CudaResMgr& other) = delete;
  CudaResMgr& operator=(CudaResMgr&& other) = delete;

  CUcontext GetCtx(size_t idx);
  CUstream GetStream(size_t idx);

  int GetVersion() const;

  ~CudaResMgr();
  static CudaResMgr& Instance();
  static size_t GetNumGpus();

  std::vector<std::pair<CUdevice, CUcontext>> g_Contexts;
  std::vector<CUstream> g_Streams;

  static std::mutex gInsMutex;
  static std::mutex gCtxMutex;
  static std::mutex gStrMutex;
};
} // namespace VPF

void UD_NV12(unsigned char* dpDstY, unsigned char* dpDstU,
             unsigned char* dpDstV, int nDstPitch, int nDstWidth,
             int nDstHeight, unsigned char* dpSrcNv12, int nSrcPitch,
             int nSrcWidth, int nSrcHeight, cudaStream_t stream);